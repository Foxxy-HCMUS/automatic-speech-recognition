1
00:00:10,060 --> 00:00:10,751
Speaker 0: Hello, everyone.

2
00:00:10,871 --> 00:00:14,192
Speaker 0: Welcome back to another round of Turing Mock Interviews.

3
00:00:14,552 --> 00:00:17,013
Speaker 0: I am José and I'm a tech leader at Turing.

4
00:00:17,353 --> 00:00:28,176
Speaker 0: I'm from Montreal, Canada, and at Turing, I work on the hiring team, helping them to hire the best engineers by helping with the vetting process.

5
00:00:28,556 --> 00:00:33,377
Speaker 0: I have more than seventeen years of experience and my expertise lies in JavaScript.

6
00:00:33,957 --> 00:00:40,403
Speaker 0: Today, I will be interviewing Victor for the role of an experienced Node.js developer.

7
00:00:40,983 --> 00:00:42,244
Speaker 0: Let's hear from Victor.

8
00:00:42,264 --> 00:00:43,205
Speaker 0: Hello, Victor.

9
00:00:43,225 --> 00:00:45,887
Speaker 0: How are you doing and how is your day doing so far?

10
00:00:45,907 --> 00:00:47,749
Speaker 0: Hi, Guilci.

11
00:00:47,849 --> 00:00:48,530
Speaker 1: I'm doing good.

12
00:00:49,150 --> 00:00:49,711
Speaker 1: How are you, too?

13
00:00:51,326 --> 00:00:51,987
Speaker 0: I'm doing great.

14
00:00:52,067 --> 00:00:53,048
Speaker 0: So thanks for asking.

15
00:00:53,228 --> 00:01:04,040
Speaker 0: So could you please introduce yourself and tell me a little bit about your experience, your past project and what kind of language framework have you been working with?

16
00:01:04,721 --> 00:01:05,762
Speaker 0: And then I can take from there.

17
00:01:07,143 --> 00:01:08,505
Speaker 1: Yes, I am Victor.

18
00:01:08,665 --> 00:01:09,746
Speaker 1: I'm from Nigeria.

19
00:01:11,230 --> 00:01:13,151
Speaker 1: I am a full stack developer.

20
00:01:13,171 --> 00:01:16,812
Speaker 1: I've been developing for about six years now.

21
00:01:17,492 --> 00:01:23,055
Speaker 1: I started my journey into the tech world by working as a backend developer.

22
00:01:23,915 --> 00:01:27,476
Speaker 1: I had started writing Python and Django framework.

23
00:01:27,976 --> 00:01:34,259
Speaker 1: At the time I was building, deploying machine learning models to the web using Django.

24
00:01:35,052 --> 00:01:40,015
Speaker 1: After two years down my career, I joined a fintech company.

25
00:01:40,495 --> 00:01:44,337
Speaker 1: In the company, I picked up JavaScript and started writing Node.js and React.

26
00:01:45,018 --> 00:01:53,642
Speaker 1: I was responsible for building various financial APIs and dashboard internal tools to help my colleagues work.

27
00:01:54,843 --> 00:02:03,628
Speaker 1: Fast forward five years from then, I have been working steadily with JavaScript and Node.js, and consequently, JavaScript and Node.js are my strengths.

28
00:02:04,485 --> 00:02:04,866
Speaker 1: Thank you.

29
00:02:05,788 --> 00:02:06,108
Speaker 0: Nice.

30
00:02:06,509 --> 00:02:07,050
Speaker 0: All right.

31
00:02:07,150 --> 00:02:10,537
Speaker 0: So you can see that you have worked hard to be here today, right?

32
00:02:11,115 --> 00:02:15,998
Speaker 0: So Python, Django, React.js, and Node.js, right?

33
00:02:16,358 --> 00:02:18,819
Speaker 0: So you'll never get out of job for sure.

34
00:02:19,020 --> 00:02:19,360
Speaker 0: I can't.

35
00:02:19,800 --> 00:02:20,060
Speaker 0: Yeah.

36
00:02:20,620 --> 00:02:21,581
Speaker 0: All right.

37
00:02:21,981 --> 00:02:22,261
Speaker 0: Okay.

38
00:02:22,301 --> 00:02:30,306
Speaker 0: So I see you have a lot of experience with back-end, front-end, Python, Django, Node.js, React.js.

39
00:02:30,406 --> 00:02:31,827
Speaker 0: This is quite a lot.

40
00:02:32,207 --> 00:02:32,507
Speaker 0: Okay.

41
00:02:32,847 --> 00:02:35,329
Speaker 0: So first of all, which one do you prefer?

42
00:02:36,573 --> 00:02:40,795
Speaker 1: Wow, yeah, that's a tricky question for me, but I would do well to answer it.

43
00:02:40,975 --> 00:02:45,078
Speaker 1: So I started writing Python and kind of fell in love with Python.

44
00:02:45,378 --> 00:02:51,661
Speaker 1: However, over the years, I've used more production applications using JavaScript and .

45
00:02:51,661 --> 00:02:57,804
Speaker 1: So if I were building some fun projects just for myself, I would maybe pick Python.

46
00:02:57,864 --> 00:03:08,314
Speaker 1: But if I wanted to come up, hit the ground fast, and build something that works, that would be deployed in production, I would always reach out for NewJS, React and JavaScript essentially.

47
00:03:08,434 --> 00:03:10,697
Speaker 1: So in a way I would say JavaScript.

48
00:03:12,360 --> 00:03:12,841
Speaker 0: That's it.

49
00:03:12,901 --> 00:03:15,925
Speaker 0: That's a smart answer because this position is for JavaScript, right?

50
00:03:15,965 --> 00:03:18,770
Speaker 0: If you say Python, okay, so you're not going.

51
00:03:19,506 --> 00:03:21,547
Speaker 0: Okay, I'm kidding, I'm kidding.

52
00:03:22,948 --> 00:03:37,058
Speaker 0: All right, so could you please tell me, let's see, could you please tell me or describe a few projects or, I mean, the best project that you have been, that you work with JavaScript, for example?

53
00:03:38,246 --> 00:03:44,411
Speaker 1: All right, so outside the project I worked with I worked on why I was working in the fintech company.

54
00:03:44,992 --> 00:03:47,554
Speaker 1: so here's the problem statement.

55
00:03:48,715 --> 00:03:55,321
Speaker 1: The company has a source bank account and the company has a multiple destination bank account.

56
00:03:56,221 --> 00:04:03,668
Speaker 1: Over time, money comes into the company from the source bank account into the source bank account, but then, in order to help.

57
00:04:04,108 --> 00:04:13,474
Speaker 1: to perform transaction, money has to move into the destination's bank account at specific time and in specific percentages.

58
00:04:14,235 --> 00:04:39,412
Speaker 1: So I was tasked to build an API that would be controlled by a dashboard that I also built that would enable the users customize how much percentage of money would go from the source bank account to various um destination bank account and also they would also be able to control how frequently um funds is deducted from the source account to destination account.

59
00:04:39,912 --> 00:04:46,295
Speaker 1: so the project involved me writing background jobs using luchas and also ready for caching and all that.

60
00:04:46,675 --> 00:04:48,036
Speaker 1: so it was a very fun project.

61
00:04:48,216 --> 00:04:51,997
Speaker 1: i went about scheduling jobs and cleaning up jobs and all.

62
00:04:52,137 --> 00:04:53,198
Speaker 1: yeah so that was it.

63
00:04:53,957 --> 00:04:57,880
Speaker 0: nice nice good to mention that good mention red is node.js.

64
00:04:59,101 --> 00:05:01,622
Speaker 0: uh okay so let's get it started.

65
00:05:01,682 --> 00:05:07,546
Speaker 0: okay um this is really interesting project and i see you have a great background.

66
00:05:08,267 --> 00:05:11,028
Speaker 0: okay uh let's go to the node.js questions.

67
00:05:11,269 --> 00:05:12,329
Speaker 0: okay all right.

68
00:05:13,330 --> 00:05:20,255
Speaker 0: um i would like to ask you okay for example uh node.js.

69
00:05:20,675 --> 00:05:21,035
Speaker 0: for first.

70
00:05:21,075 --> 00:05:23,637
Speaker 0: first of all node.js is single thread or multi application.

71
00:05:25,717 --> 00:05:33,499
Speaker 1: it's a single javascript is a single traded language, however, node.js allows javascript to be able to run.

72
00:05:34,620 --> 00:05:40,342
Speaker 1: However, node.js kind of augments the fact that javascript is single traded by providing an event.

73
00:05:40,542 --> 00:05:47,484
Speaker 1: so while javascript is single traded, you can run, you can perform concurrent operations using node.js.

74
00:05:49,466 --> 00:05:54,412
Speaker 1: node.js and the event loop right and yes node.js and the event loop.

75
00:05:54,552 --> 00:05:57,703
Speaker 0: so yeah okay great that's a good answer.

76
00:05:58,083 --> 00:05:59,103
Speaker 0: well what else?

77
00:05:59,843 --> 00:06:11,106
Speaker 0: uh if as you mentioned node.js is a single thread okay application uh it goes to one single core and stay there forever right until we reset it.

78
00:06:11,787 --> 00:06:19,649
Speaker 0: my question for you is how can we make node.js or multi-threading or simulate multi-threading with node.js?

79
00:06:20,663 --> 00:06:29,185
Speaker 1: Yeah, so Node.js comes with a tool called fork.

80
00:06:29,625 --> 00:06:32,886
Speaker 1: So generally, a fork is used to spawn shared processes.

81
00:06:33,787 --> 00:06:40,188
Speaker 1: In Node.js, it is used to create a new instance of the VEAD engine to run multiple workers to execute code.

82
00:06:40,648 --> 00:06:48,931
Speaker 1: So by creating a fork, Node.js can spread these operations via the multiple workers on the various cores of the host machine.

83
00:06:51,363 --> 00:06:55,885
Speaker 0: essentially yeah kind of yeah.

84
00:06:56,325 --> 00:06:58,586
Speaker 0: yeah no no that that's that's okay.

85
00:06:58,846 --> 00:06:59,967
Speaker 0: yeah i kind of that.

86
00:07:00,627 --> 00:07:06,189
Speaker 0: and uh um have you ever heard about v-eight engine?

87
00:07:07,550 --> 00:07:08,110
Speaker 1: yes i have.

88
00:07:08,490 --> 00:07:13,212
Speaker 1: it's one of the javascript engines provided by google nice.

89
00:07:13,432 --> 00:07:15,073
Speaker 0: and why node.js uses v-eight.

90
00:07:16,194 --> 00:07:26,666
Speaker 1: so um essentially when via engine is an option is an open source engine within in C++ and developed by Google.

91
00:07:27,186 --> 00:07:30,528
Speaker 1: it runs in Google chrome, unlike other engines, it is.

92
00:07:31,641 --> 00:07:33,502
Speaker 1: also utilized for Pop!

93
00:07:33,582 --> 00:07:34,662
Speaker 1: One Node.js runtime.

94
00:07:34,962 --> 00:07:40,045
Speaker 1: So VH was initially intended to improve the speed of JavaScript execution within browsers.

95
00:07:40,745 --> 00:07:47,788
Speaker 1: Instead of employing an interpreter, VH converts JavaScript code into more efficient machine code to increase performance.

96
00:07:48,448 --> 00:07:54,430
Speaker 1: It turns JavaScript code into machine code during execution by utilizing just-in-time compiler.

97
00:07:56,010 --> 00:08:04,760
Speaker 1: So, um, in order to run JavaScript on the server side, uh, with, um, on the server side, speed is essential.

98
00:08:05,020 --> 00:08:12,509
Speaker 1: and with VH, JavaScript, uh, with VS just in time compilation, JavaScript can be run faster on the server side.

99
00:08:12,589 --> 00:08:14,351
Speaker 1: And that's why Node.js uses VH.

100
00:08:16,414 --> 00:08:16,554
Speaker 0: Cool.

101
00:08:17,639 --> 00:08:18,800
Speaker 0: Thank you for this answer.

102
00:08:20,121 --> 00:08:20,662
Speaker 0: Let's see.

103
00:08:22,603 --> 00:08:23,264
Speaker 0: Let's see.

104
00:08:23,364 --> 00:08:27,627
Speaker 0: So you mentioned the event loop Node.js, okay?

105
00:08:27,707 --> 00:08:31,751
Speaker 0: Could you explain to me what is the event loop?

106
00:08:32,712 --> 00:08:32,932
Speaker 1: Yes.

107
00:08:33,251 --> 00:08:39,457
Speaker 1: So the event loop is what allows Node.js to perform non-blocking IEO operations.

108
00:08:40,337 --> 00:08:49,547
Speaker 1: So despite the fact that JavaScript is single-threaded, Usually, by affording operations to the system kernel whenever possible.

109
00:08:51,008 --> 00:08:58,631
Speaker 1: Since most kernels are multi-threaded, they can have multiple operations executed in the background.

110
00:08:59,252 --> 00:09:05,915
Speaker 1: When one of these operations completes, the kernel tells Node.js so that the appropriate callback can be added to the POQ.

111
00:09:06,975 --> 00:09:15,563
Speaker 1: Essentially, the event loop is the mechanism through which Node.js uses a single traded language of JavaScript to still perform multiple operations.

112
00:09:16,504 --> 00:09:16,905
Speaker 1: That's it.

113
00:09:17,385 --> 00:09:19,847
Speaker 1: And in the event loop, there are different phases.

114
00:09:20,008 --> 00:09:21,689
Speaker 1: I could go on and elaborate about it.

115
00:09:21,909 --> 00:09:23,631
Speaker 0: Yeah, I'm good.

116
00:09:23,811 --> 00:09:24,272
Speaker 0: I'm good.

117
00:09:24,492 --> 00:09:25,313
Speaker 0: I'm good with this.

118
00:09:25,353 --> 00:09:26,213
Speaker 0: Yeah.

119
00:09:26,274 --> 00:09:28,155
Speaker 0: This kind of question is just to know.

120
00:09:28,836 --> 00:09:35,277
Speaker 0: if you are familiarized with the engine with Node.js, you know, yeah.

121
00:09:35,898 --> 00:09:44,343
Speaker 0: Okay, this one is a classic question, okay, classic Node.js question that you'll be asking a lot during the interview like this.

122
00:09:45,904 --> 00:09:48,925
Speaker 0: My question is, what do you understand about callbacks?

123
00:09:51,407 --> 00:10:10,753
Speaker 1: All right, so callbacks are a way of, in Node.js, a way of performing an operation asynchronous with the callbacks essential functions that are passed into um another function or any other asynchronous process to be called at the later time and that time is usually indeterminate.

124
00:10:11,293 --> 00:10:13,014
Speaker 1: um but um.

125
00:10:13,054 --> 00:10:20,498
Speaker 1: so the callback those functions are registered with event loop and at the later time they will be called nice.

126
00:10:20,938 --> 00:10:23,440
Speaker 0: and have you ever heard about callback health?

127
00:10:24,212 --> 00:10:32,381
Speaker 1: Yeah, callback health is a problem that arises usually when developers try to implement asynchronous processes one after the other.

128
00:10:33,162 --> 00:10:37,988
Speaker 1: So there are lots of ways to solve callback health.

129
00:10:38,829 --> 00:10:45,036
Speaker 1: More recently, you could use async-await, but the general strategy is modularization.

130
00:10:45,536 --> 00:10:53,723
Speaker 1: you can break up callbacks into independent functions and another strategy is to use a control library that is like async.

131
00:10:54,123 --> 00:10:59,367
Speaker 1: or however more recently you can use the new escs feature async await.

132
00:10:59,927 --> 00:11:11,976
Speaker 1: another way of reducing or eliminating callback here is to use a javascript generators with promises nice generators nice all right great answer all right.

133
00:11:12,016 --> 00:11:19,503
Speaker 0: so um let's see uh what kind of framework uh have been used with node.js?

134
00:11:20,784 --> 00:11:23,046
Speaker 1: yeah i'm familiar with a couple of frameworks.

135
00:11:23,086 --> 00:11:24,828
Speaker 1: with node.js um i've used.

136
00:11:24,848 --> 00:11:30,734
Speaker 1: i've worked with express i've worked with core i've also worked with nest.js.

137
00:11:32,482 --> 00:11:38,425
Speaker 1: Those are essentially the ones that I've worked very much with and quick proficiency in.

138
00:11:39,425 --> 00:11:39,685
Speaker 0: Nice.

139
00:11:40,105 --> 00:11:41,046
Speaker 0: Okay, great.

140
00:11:41,226 --> 00:11:41,786
Speaker 0: That's great.

141
00:11:43,007 --> 00:11:48,329
Speaker 0: What's the difference between ExpressJS and NestJS, for example?

142
00:11:49,517 --> 00:11:55,405
Speaker 1: So XpressJS is a framework on Node.js, just like NestJS.

143
00:11:55,705 --> 00:12:00,051
Speaker 1: However, XpressJS is more world-level.

144
00:12:00,632 --> 00:12:11,868
Speaker 1: It gives you more exposure to the internal workings of James Forrest, Norcal PTACC, Norcal PTACC, Not just have no just call library and also, it is not it's on opinionated so.

145
00:12:11,888 --> 00:12:27,135
Speaker 1: James Forrest, Norcal PTACC, Norcal PTACC, Whereas messages is the higher level framework, which can also be used with messages or classify messages is more opinionated and introduces advanced concept like dependency injection and.

146
00:12:27,555 --> 00:12:32,016
Speaker 1: has some certain ideas or opinion on how to structure your code.

147
00:12:33,136 --> 00:12:43,058
Speaker 1: NestJS should be prioritized or should be used in where you want to build a very large application and you want to achieve structure and the code that would be maintainable over time.

148
00:12:43,198 --> 00:12:47,739
Speaker 1: However, if you want something quick and small, I would go with ExpressJS.

149
00:12:49,639 --> 00:12:50,480
Speaker 0: Okay, great.

150
00:12:51,640 --> 00:12:54,380
Speaker 0: You mentioned dependency injection.

151
00:12:54,640 --> 00:12:56,901
Speaker 0: Okay, what's dependency injection?

152
00:12:57,816 --> 00:13:15,325
Speaker 1: So dependency injection is a mechanism that allows the framework to be able to identify certain tokens or services that have been pre-configured in the code and inject it into other services in runtime.

153
00:13:15,746 --> 00:13:43,740
Speaker 1: So instead of the writing manual code to instantiate objects and pass it to various functions, the developer can more or less write the services and the functions and then the dependency injection engine would take appropriate classes and instantiate with an instance of it at the time when it needs it and so in that sense it makes the code a bit more declarative and instead of imperative.

154
00:13:44,561 --> 00:13:50,746
Speaker 1: so it's also a medium for for allowing you to write more decoupled codes.

155
00:13:51,867 --> 00:13:52,127
Speaker 0: Nice.

156
00:13:52,567 --> 00:13:52,927
Speaker 0: Okay.

157
00:13:53,468 --> 00:13:53,728
Speaker 0: All right.

158
00:13:53,988 --> 00:13:54,889
Speaker 0: And let's see.

159
00:13:55,489 --> 00:13:58,912
Speaker 0: What do you understand about streaming in Node.js?

160
00:14:00,433 --> 00:14:00,894
Speaker 1: Streaming.

161
00:14:01,214 --> 00:14:15,946
Speaker 1: So streaming is a way of managing data or passing or working with data that allows data to be processed without being read completely into the memory.

162
00:14:16,426 --> 00:14:25,753
Speaker 1: For example, if you have a large collection of data, it might not be pragmatic to read all the data into memory before processing it.

163
00:14:26,174 --> 00:14:32,479
Speaker 1: But when you employ streaming, you can read the data chunk by chunk and process small chunks at a time.

164
00:14:32,879 --> 00:14:37,322
Speaker 1: In that way, you can circumvent the memory constraint of the system.

165
00:14:41,297 --> 00:14:47,863
Speaker 1: So, Node.js, many of the Node.js core libraries like the event emitters are built around streams.

166
00:14:49,064 --> 00:14:49,764
Speaker 0: Okay, great.

167
00:14:50,865 --> 00:14:52,727
Speaker 0: I'm glad that you mentioned event emitters.

168
00:14:52,907 --> 00:14:55,349
Speaker 0: So, what are event emitters?

169
00:14:55,429 --> 00:14:57,210
Speaker 0: What do you understand about event emitters?

170
00:14:58,091 --> 00:15:09,601
Speaker 1: So, event emitters are a way of writing... Okay, in the situations we have used event emitters, event emitters are used to write more decoupled codes.

171
00:15:10,214 --> 00:15:21,170
Speaker 1: So essentially, the way it works, there is an event is dispatched, and there is a listener function that is registered with that event.

172
00:15:21,811 --> 00:15:32,319
Speaker 1: So whenever an action happens and an event is dispatched, all the waste in us, which are just functions registered to the event are executed.

173
00:15:32,799 --> 00:15:37,560
Speaker 1: So from a programmer's perspective, it can allow you to write code that is decoupled.

174
00:15:37,801 --> 00:15:48,864
Speaker 1: Let's say you want to communicate across services without having to import all the implementation detail of one service into another file, you can use event emitters to communicate synchronously.

175
00:15:51,300 --> 00:15:59,327
Speaker 0: And what's the difference between event emitters and publisher and subscriber design pattern?

176
00:16:01,889 --> 00:16:08,754
Speaker 1: So event emitters, there are more similarities than there are differences.

177
00:16:09,215 --> 00:16:31,532
Speaker 1: However, what I would say is for publisher and subscriber design pattern, there needs to be an established topic in which all publishers will publish to, then the subscribers will be registered on the same topic and listening for messages coming from that topic.

178
00:16:32,133 --> 00:16:33,475
Speaker 1: That's my understanding.

179
00:16:34,076 --> 00:16:39,861
Speaker 1: But yeah and then also the use cases kind of present some differences.

180
00:16:40,321 --> 00:16:43,024
Speaker 1: so but we just describe a pattern.

181
00:16:43,264 --> 00:16:45,126
Speaker 1: most times can be used across.

182
00:16:46,467 --> 00:16:57,917
Speaker 1: Various services across the across http protocol, whereby we have this script publisher and one service, and this is quite by another service, however, event emitters.

183
00:16:58,497 --> 00:17:02,720
Speaker 1: their scope of communications is limited within the same local service.

184
00:17:03,040 --> 00:17:08,282
Speaker 1: so maybe you have one service in one file and you want to publish an event to another service another file.

185
00:17:09,083 --> 00:17:10,424
Speaker 1: so that's my understanding.

186
00:17:11,164 --> 00:17:14,126
Speaker 0: makes sense yeah makes sense all right.

187
00:17:14,205 --> 00:17:17,988
Speaker 0: so uh what kind of database are you familiar with?

188
00:17:18,068 --> 00:17:18,508
Speaker 0: node.js?

189
00:17:18,888 --> 00:17:20,990
Speaker 0: i mean not with node.js at all.

190
00:17:21,010 --> 00:17:23,090
Speaker 0: uh what kind of days are you familiar with?

191
00:17:23,871 --> 00:17:29,135
Speaker 1: So I've worked with PostgreSQL and I've worked with MongoDB.

192
00:17:29,555 --> 00:17:35,359
Speaker 1: However, I would say I'm more familiar with MongoDB than PostgreSQL with Node.js.

193
00:17:36,840 --> 00:17:44,085
Speaker 1: So while working with PostgreSQL with Node.js, most of the time I've used the OLMs, object relational mappers.

194
00:17:44,945 --> 00:17:51,830
Speaker 1: However, and also while working with Mongo, I used the Mongo's ODM object data mapper.

195
00:17:52,614 --> 00:17:58,121
Speaker 1: So in terms of proficiency, MongoDB is where I'm more proficient at.

196
00:17:59,543 --> 00:18:04,410
Speaker 0: In your understanding, what's the difference between MongoDB and PostgreSQL?

197
00:18:05,606 --> 00:18:23,476
Speaker 1: All right, a major difference between mongodb and postgres is the fact that mongodb is, or rather postgres is a relational database, meaning that it stores data in a structured form in tables that have rows and columns.

198
00:18:24,136 --> 00:18:31,640
Speaker 1: However, mongodb is a non-relational database, oftentimes it is also called a new SQL database.

199
00:18:34,570 --> 00:18:45,100
Speaker 1: There's some of the differences also between the two come from the fact that there's a standard query language for querying Postgres.

200
00:18:45,400 --> 00:18:49,684
Speaker 1: That's why Postgres is also for an SQL database.

201
00:18:50,285 --> 00:18:57,672
Speaker 1: And whereas MongoDB allows stores this information in key data and I mean, key value pairs.

202
00:18:58,675 --> 00:19:06,645
Speaker 1: So in summary, Postgres is a relational database that stores its information in tables in a more structured form.

203
00:19:08,427 --> 00:19:15,056
Speaker 1: MongoDB stores its information in a key-value pair, which allows it doesn't have much of structure, but it's more flexible.

204
00:19:16,348 --> 00:19:22,391
Speaker 0: I'm going to ask you a few questions related to SQL database and non-SQL database.

205
00:19:22,451 --> 00:19:23,492
Speaker 0: in the end, okay?

206
00:19:23,692 --> 00:19:29,135
Speaker 0: But for now, I'd like to ask you if you, do you have any experience with WebSockets?

207
00:19:29,955 --> 00:19:32,937
Speaker 1: Yes, I have some experience with WebSockets.

208
00:19:33,437 --> 00:19:41,101
Speaker 1: Maybe not in a full-scale experience, but I have used some projects with WebSockets, so I can attempt questions in WebSocket.

209
00:19:41,997 --> 00:19:53,783
Speaker 0: Nice what's the difference between one application that use web sockets to communicate with the back end and one application that use restful api's to do the same.

210
00:19:54,844 --> 00:19:59,106
Speaker 1: So generally web sockets are used when you want to and.

211
00:19:59,747 --> 00:20:03,570
Speaker 1: build real time features on a server.

212
00:20:04,150 --> 00:20:16,438
Speaker 1: So usually RESTful API works with a request response cycle, meaning that for a server to send information to the client, the client has to first of all, make a request.

213
00:20:17,222 --> 00:20:34,314
Speaker 1: But with WebSocket, you kind of introduce a dual method of communication, meaning the client can make a request to the server, and the server, at any time it has data, can push data to the client without the client having to initiate the request.

214
00:20:34,694 --> 00:20:42,800
Speaker 1: So with that ability, a real-time application can be built, and WebSocket enables this ability, provides this ability to servers.

215
00:20:44,707 --> 00:20:44,967
Speaker 0: Great.

216
00:20:45,869 --> 00:20:48,172
Speaker 0: And do you have experience with GraphQL?

217
00:20:49,634 --> 00:20:51,757
Speaker 1: Yes, I've had some experience with GraphQL.

218
00:20:52,578 --> 00:20:52,778
Speaker 1: Yes.

219
00:20:54,180 --> 00:20:54,481
Speaker 0: Okay.

220
00:20:54,721 --> 00:20:56,523
Speaker 0: How would you describe GraphQL?

221
00:20:56,664 --> 00:20:57,405
Speaker 0: What's GraphQL?

222
00:20:58,351 --> 00:21:06,853
Speaker 1: So GraphQL can be, I can describe or exemplify GraphQL by making some comparison with ETH and REST.

223
00:21:07,113 --> 00:21:13,254
Speaker 1: So essentially GraphQL was introduced to augment some of the deficiencies of REST framework.

224
00:21:13,695 --> 00:21:30,724
Speaker 1: So usually the RESTful framework endpoints are defined ahead of time, payloads that endpoint are defined ahead of time and the response, the shape of the response from the rest to API defined ahead of time with minimal flexibility.

225
00:21:31,205 --> 00:21:43,970
Speaker 1: But with GraphQL, you're provided an interface in which a client can query the server with varied payload and can get varied response.

226
00:21:44,130 --> 00:21:51,573
Speaker 1: so in a situation where the client wants to just get enough data that it needs it will not be over with it with too much data.

227
00:21:51,953 --> 00:22:02,958
Speaker 1: and when a client wants to request for maybe data involving various resources with a single endpoint and with a single query the server the client can make that request.

228
00:22:03,058 --> 00:22:21,418
Speaker 1: so essentially GraphQL makes up for RESTful API in terms of introducing flexibility of queries and also decreasing the amount of information that is transferred by the network by allowing the client to specify exactly what he needs and what he doesn't need.

229
00:22:23,055 --> 00:22:25,776
Speaker 0: essentially great great all right.

230
00:22:25,856 --> 00:22:28,417
Speaker 0: so um we gotta come to the end.

231
00:22:28,677 --> 00:22:36,840
Speaker 0: okay before i ask you a few more questions i just like to give uh uh heads up for our fellow developers that are watching this video.

232
00:22:37,140 --> 00:22:40,761
Speaker 0: okay so if you are looking for jobs okay uh job opportunities.

233
00:22:41,241 --> 00:22:44,002
Speaker 0: i recommend you to go to the website student.com.

234
00:22:44,042 --> 00:22:44,602
Speaker 0: slash jobs.

235
00:22:44,982 --> 00:22:52,625
Speaker 0: okay you can find jobs by your tech stack And once you find them, so all you need to do is just create your account if you don't have one.

236
00:22:53,025 --> 00:22:56,966
Speaker 0: OK, and pass through the vetting process once you pass.

237
00:22:57,346 --> 00:23:01,028
Speaker 0: So you find a job as a victor as I did.

238
00:23:01,048 --> 00:23:01,728
Speaker 0: OK.

239
00:23:02,168 --> 00:23:07,490
Speaker 0: And then you start working one hundred percent remotely from the country that you want.

240
00:23:07,730 --> 00:23:07,990
Speaker 0: OK.

241
00:23:08,130 --> 00:23:09,491
Speaker 0: Any place in the world.

242
00:23:10,231 --> 00:23:11,031
Speaker 0: Okay, let's go.

243
00:23:11,071 --> 00:23:12,792
Speaker 0: Let's just come back for Victor.

244
00:23:12,972 --> 00:23:18,654
Speaker 0: But before that, if you enjoyed this content, just consider giving us the big thumbs up and commenting down below.

245
00:23:20,014 --> 00:23:21,115
Speaker 0: What is your tech stack?

246
00:23:21,295 --> 00:23:21,555
Speaker 0: Okay.

247
00:23:21,655 --> 00:23:23,656
Speaker 0: And what kind of job are you looking for?

248
00:23:24,296 --> 00:23:24,936
Speaker 0: Okay, Victor.

249
00:23:24,976 --> 00:23:26,817
Speaker 0: So we're coming to the end.

250
00:23:27,057 --> 00:23:27,337
Speaker 0: Okay.

251
00:23:27,377 --> 00:23:29,158
Speaker 0: I just have a few more questions for you.

252
00:23:31,719 --> 00:23:38,161
Speaker 0: So how do you keep yourself up to date with Node.js?

253
00:23:39,687 --> 00:23:39,967
Speaker 1: All right.

254
00:23:40,367 --> 00:23:48,610
Speaker 1: So first of all, I have a Medium account and I have daily subscriptions.

255
00:23:48,790 --> 00:23:57,172
Speaker 1: So with Medium, you can subscribe to some channels to give you some daily doses of articles written in your favorite stack.

256
00:23:57,372 --> 00:24:01,273
Speaker 1: For me, I subscribe to Node.js updates.

257
00:24:01,693 --> 00:24:07,075
Speaker 1: So every morning I check my email for the daily dose of Node.js, I read some articles.

258
00:24:07,915 --> 00:24:10,096
Speaker 1: just to find out what's more recent.

259
00:24:10,576 --> 00:24:21,539
Speaker 1: Then sometimes I occasionally go to the NPM website and just browse for packages to see what is currently being developed by the various, by the community.

260
00:24:22,120 --> 00:24:29,222
Speaker 1: Then oftentimes I also take some courses, some professional courses to improve my skills in Node.js.

261
00:24:29,813 --> 00:24:34,856
Speaker 1: And then finally, this might sound obvious, but I want to emphasize it.

262
00:24:35,076 --> 00:24:38,938
Speaker 1: Just keep practicing, and especially targeted practice.

263
00:24:39,338 --> 00:24:48,743
Speaker 1: Whenever I realize that I have some deficiencies or some struggles in a particular area of Node.js, I go to the Node.js documentation.

264
00:24:49,163 --> 00:24:56,827
Speaker 1: I try to implement projects that would task my knowledge on such concepts.

265
00:24:57,187 --> 00:24:59,208
Speaker 1: So over time, I get better at Node.js.

266
00:24:59,748 --> 00:25:19,972
Speaker 1: And then there's always room for improvement in JavaScript, because even though Node.js is not exactly JavaScript, even though Node.js is more than JavaScript, getting stronger or better in JavaScript would definitely improve your skills in Node.js.

267
00:25:20,713 --> 00:25:26,194
Speaker 1: So those are a few tips that I use to improve my Node.js and JavaScript in general.

268
00:25:26,814 --> 00:25:27,154
Speaker 1: Thank you.

269
00:25:28,117 --> 00:25:28,758
Speaker 0: Great, Victor.

270
00:25:28,878 --> 00:25:29,398
Speaker 0: Thank you.

271
00:25:30,239 --> 00:25:32,561
Speaker 0: It was really nice to speak with you today.

272
00:25:33,362 --> 00:25:41,329
Speaker 0: And to everybody else, thank you for attending this mock interview with us again, and hope you enjoyed this video as much as I did.

273
00:25:42,089 --> 00:25:47,714
Speaker 0: And we'll be back very soon with more episodes like this for any tech stack.

274
00:25:47,774 --> 00:25:51,417
Speaker 0: Please comment below what tech stack would like to cover.

275
00:25:51,518 --> 00:25:52,298
Speaker 0: that we cover.

276
00:25:52,338 --> 00:25:54,060
Speaker 0: We can create mock interview for that.

277
00:25:54,580 --> 00:25:58,663
Speaker 0: and then you can prepare yourself better for this kind of interview.

278
00:25:58,683 --> 00:26:06,128
Speaker 0: okay uh please drop your suggestions comments hit the like button subscribe to touring's uh.

279
00:26:06,168 --> 00:26:08,849
Speaker 0: youtube channel and don't forget to.

280
00:26:09,109 --> 00:26:13,952
Speaker 0: uh don't forget to to give us the big fat thumbs up for this video if you enjoyed this content.

281
00:26:13,973 --> 00:26:17,695
Speaker 0: okay take care stay safe wash your hands and happy coding.
